# Group 02 大作业报告

# 主要分工

- 高信龙一
	- riscv32在uCore+上的移植
	- 将g08组的riscv64+smp分支到最新uCore+上的移植 
- 杨国烨
	- 将CI技术加入最新的uCore+上
	- 与g08组共同完成riscv上的smp技术 

# RISC-V简介

## Software Stack Terminology

支持不同模式的虚拟化

1. AEE(Application Execution Environment) --> Application
2. SEE(Supervisor Execution Environment) --> OS --> Application
3. HEE(Hypervisor Execution Environment) --> Hypervisor --> OS --> Application

## Privilege Levels

At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode in one or more CSRs (control and status registers).

| Level | Encoding | Name Abbreviation |
| - | :-: | :-: |
|0| 00| User/Application U|
|1| 01| Supervisor S|
|2| 10| Reserved|
|3| 11| Machine M|
<center>Table 1: RISC-V privilege levels.</center>

## [文档v1.10](https://riscv.org/specifications/privileged-isa/)

### riscv1.9到1.10的主要改动

- The interrupt-enable stack discipline has been simplified.
- Optional vectored interrupt support has been added to the `mtvec`(Machine trap-handler base address) and `stvec`(Supervisor trap handler base address) CSRs.
- The SEIP and UEIP bits in the `mip`(Machine interrupt pending) CSR have been redefined to support software injection of external interrupts.
- In systems with only M-mode, or with both M-mode and U-mode but without U-mode trap support, the `medeleg`(Machine exception delegation register) and `mideleg`(Machine interrupt delegation register) registers now do not exist, whereas previously they returned zero.
- The supervisor virtual memory configuration has been moved from the `mstatus`(Machine status register) register to he `sptbr`(Page-table base register) register. Accordingly, the `sptbr` register has been renamed to `satp` (Supervisor Address Translation and Protection) to reflect its broadened role.
- H-mode has been removed, as we are focusing on recursive virtualization support in S-mode. The encoding space has been reserved and may be repurposed at a later date.

# 现有工作综述

## [riscv-tools](https://github.com/riscv/riscv-tools)

### 组成

* `riscv-gnu-toolchain`, a RISC-V cross-compiler
* `riscv-fesvr`, a "front-end" server that services calls between the host and target processors on the Host-Target InterFace (HTIF) (it also provides a virtualized console and disk device)
* `riscv-isa-sim`, the ISA simulator and "golden standard" of execution
* `riscv-opcodes`, the enumeration of all RISC-V opcodes executable by the simulator
* `riscv-pk`, a proxy kernel that services system calls generated by code built and linked with the RISC-V Newlib port (this does not apply to Linux, as _it_ handles the system calls)
* `riscv-tests`, a set of assembly tests and benchmarks

### Bootstrapping

[riscv-pk](https://github.com/riscv/riscv-pk)
这个包内包含了Berkeley Boot Loader (bbl) 

- a supervisor execution environment for tethered RISC-V systems, designed to host the RISC-V Linux port.

### Qemu

[riscv-qemu](https://github.com/riscv/riscv-qemu)
用于支持riscv架构的模拟器

## [bbl-ucore](https://ring00.github.io/bbl-ucore)

本工作基于RISC-V1.9，完成ucore从x86到riscv32位在8个试验上的迁移，其[Wiki](https://ring00.github.io/bbl-ucore/#/?id=bbl-ucore)详细描述了RISC-V体系结构，包含但不仅限于：
* 模块化指令集
* 虚拟化与软件栈
* 特权级
* 控制/状态寄存器
* 函数调用的规定

## [bbl-ucore64](https://gitee.com/shzhxh/ucore_os_lab/tree/riscv64-priv-1.10)

本工作基于RISC-V1.10，完成ucore从riscv32位到riscv64位在8个试验上的迁移

## [uCore-plus](https://github.com/chyyuu/ucore_os_plus)

# ucore+ 整体框架

ucore+的主要特点为通过编译中传入不同的参数，实行多平台平行支持

## 主体文件结构

```project
│   README.md
│   README.i386    
│   README.amd64
│   ...
│
└───ucore
│   │   Makefile
│   │   uCore_gdb
│   │   uCore_run
│   │   uCore_test
│   │
│   └───obj
│   └───src
│       └───bootloader
│       └───kern-ucore
│       │   │   Makefile.build
│       │   │
│       │   └───arch
│       │       └───i386
│       │       └───amd64
│       │       └───...
│       │
│       └───libs-user-ucore
│   
└───riscv-pk
    │   Makefile.in
    │
    └───bbl
    └───machine
```

## 硬件相关

主要包括了以下几个部分：

### bootloader

与ucore实现一致，riscv中将使用bbl (https://ring00.github.io/bbl-ucore/#/toolchain-overview)

### arch

与硬件相关的代码大部分都被放置在`arch`目录下。

相对于ucore，增加了kmodule（内核可加载模块）和numa

以i386平台为例，与ucore类似，OS入口从kern_init开始，然后进一步初始化并建立页表映射，中断使能，进程切换，各个设备驱动

```c
	cons_init();		// init the console

	const char *message = "(THU.CST) os is loading ...";
	kprintf("%s\n\n", message);

	mp_init(); /* Only to initialize lcpu_count. */

	debug_init();		// init debug registers
	pmm_init();		// init physical memory management
	pmm_init_ap();

	pic_init();		// init interrupt controller
	idt_init();		// init interrupt descriptor table

	vmm_init();		// init virtual memory management
	sched_init();		// init scheduler
	proc_init();		// init process table
	sync_init();		// init sync struct

	ide_init();		// init ide devices
#ifdef UCONFIG_SWAP
	swap_init();		// init swap
#endif
	fs_init();		// init fs

	clock_init();		// init clock interrupt
	mod_init();

	intr_enable();		// enable irq interrupt

	/* do nothing */
	cpu_idle();		// run idle process
```

每个arch有自己的default_defconfig，用来配置自己平台的工具链等

ucore.ld.in中配置了内核态的代码段设置

### libs-user-ucore

用户态相关，代码段的设置，syscall等

## 硬件无关

相对于ucore，ucore+将硬件无关部分提取出来，合理一些，包含并不限于kern-ucore

* 完全
	* fs
	* schedule
	* sync
* 部分
	* libs
	* mm
	* process

# riscv32 in uCore+

大部分与riscv32 in uCore相似，详细可见[bbl-ucore](https://ring00.github.io/bbl-ucore/)

## 硬件无关部分的改动

- pmm.c
	- get_pte: 页表标记位设置
	- get_page
- vmm.c & proc.c
	- ptep_set_exe: 设置“执行”位

### 难点

在移植过程中，发现以下问题：load_icode 函数会调用 proc_load_elf 函数来把用户程序装载进内存 ( proc_load_elf->proc_elf_load_program->load_icode_read ) 最终 load_icode_read 直接把读出来的程序代码段往 elf header 中指定的虚地址放，也就是说它直接把数据往内核虚地址 0x800020 的地方写，因此产生了 store page fault

最后发现原因在于：vmm.c 第1060行，从share memory取出的页表项(page table entry)被当作页(page)处理，而这个在i386平台下恰好没有出问题

```c
if (ptep_present(sh_ptep)) {
-		page_insert(mm->pgdir, pa2page(*sh_ptep), addr,
+		page_insert(mm->pgdir, pte2page(*sh_ptep), addr,
			perm);
} else {
```

## configs

存放default config，包括工具链、默认调度算法、默认文件系统的设置

## init

### init.c

- 删除`lab1-challenge`相关的测试。
- 新增初始化：
  - `mp_init`，用于初始化NUMA架构
  - `debug_init`，用于初始化新增的debug寄存器
  - `pmm_init_ap`
  - `sync_init`，调用`mbox_init`，初始化消息邮箱

## kmodule

### mod.c

这是一个全新的模块，涉及到动态可加载模块

- `apply_relocate`，将section重定向，涉及R_RISCV_NONE，R_RISCV_32等模式，[参考资料](https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md)

## libs

arch.c，sbi.c从libs直接移到这里

主要实现以下两个文件

- atomic.c
	- riscv下的原子操作
- spinlock.c
	- riscv下的自旋锁，通过`__sync_bool_compare_and_swap`实现

##mm 

### buddy_pmm.h & buddy_pmm.c

将页分配算法更换为伙伴系统。从而删除了`default_pmm.h/c`和`kmalloc.h/c`。

### memlayout.h

- 将`struct Page`修改：
	- 添加`zone_num`为buddy stytem所用
	- ref设置为原子量（其实就是含有volatile int的一个struct，要求编译器每次读取该值时都从内存中读取而不是从寄存器中）
	- 将swap机制通用化（原先ucore只有lab3才有）
- 新增加了页表项的标志位和对应的操作语句，例如`PG_dirty`,`SetPageDirty`

### mmu.h

首先需要介绍一些riscv32下的页机制，一个riscv32虚拟地址的结构如下

```
31                 22 21                12 11                     0
+--------------------+--------------------+------------------------+
|       VPN[1]       |       VPN[0]       |      page offset       |
+---------10---------+---------10---------+----------12------------+
```

一个riscv32物理地址的结构如下

```
33                     22 21                12 11                     0
+------------------------+--------------------+------------------------+
|         PPN[1]         |       PPN[0]       |       page offset      |
+-----------12-----------+---------10---------+-----------12-----------+
```

riscv32中一个页表项结构如下

```
31                     20 19                10 9      8 7 6 5 4 3 2 1 0
+------------------------+--------------------+--------+---------------+
|         PPN[1]         |       PPN[0]       |Reserved|D|A|G|U|X|W|R|V|
+-----------12-----------+---------10---------+----2---+-------8-------+
```

由于ucore+考虑到了平台之间的兼容性，新增了更多的多级页表，新增了页表项的操作函数（更加OOP）。为此32位的系统也需要实现高级页表的映射，在这里只需要将三级、四级页表映射为二级页表即可，例如`#define PMD_ADDR(pmd)   PTE_ADDR(pmd)`，同时根据上述riscv32的页机制，完成对页表项、页的操作函数的实现

### pmm.h & pmm.c

改动较多，这里主要介绍几个，详见源代码

- 添加`TEST_PAGE`，删除测试程序中的魔数
- 修改关于页表建立的测试程序`check_pgdir`,`check_boot_pgdir`
- 根据多级页表，以及riscv的页机制，添加页表相关项与地址相关项间的转换函数，如`page2ppn`，`pmd2page`
- 添加当前页表与地址空间的映射的函数`map_pgdir`,以及对应的保存函数`set_pgdir`
- `page_init`时调大初始化的内存

###vmm.c

删除了许多通用的函数，放到了硬件无关的vmm.c。


## NUMA

在riscv中用不到，其本意与smp类似，为了解决多核并行系统而设计（后续smp会提到），为了对ucore+的兼容，直接参考i386分支下的实现

## process

### proc.c

- `alloc_proc` 根据新的`struct proc`修改初始化函数（包含删除ucore lab6中无用的部分）
- `do_fork` 大部分硬件无关部分已被移出，只有载入用户程序时用到的部分得到保留
```c
// Keep sstatus
uintptr_t sstatus = tf->status;
memset(tf, 0, sizeof(struct trapframe));
tf->gpr.sp = stacktop;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

### procentry.S

涉及进程切换

forkrets为trap/trapentry.S中的函数
```
    .globl forkrets
forkrets:
    # set stack to this new process's trapframe
    move sp, a0
    j __trapret
```
执行完`__trapret`后，进程会到达在`tf->epc`中设置的
```
.text
# void kernel_thread(void)
.globl kernel_thread_entry
kernel_thread_entry:        
    move a0, s1
    jalr s0

    jal do_exit
```
这里`s0`和`s1`就是之前在proc.c中的`kernel_thread`设置好的`fn`和`arg`，至此，内核进程切换完成。


## syscall

增加了一些syscall

## trap

### trap.c

- pgfault_handler
ucore+中的error code在riscv中无用处

- trap_dispatch
RISC-V ISA规定当scause的Most Significant Bit (MSB) 为0时表示exception，为1时表示interrupt，因此我们可以通过(intptr_t)tf->cause的符号快速判断trap的类型，接下来只需在interrupt_handler和exception_handler中做相应处理即可。

注：需要修改bbl中的mtrap.c，用来启动用户进程里的中断转发
```
redirect_trap(read_csr(mepc), read_csr(mstatus), read_csr(mbadaddr));
```

## makefile相关

相对于其它平台，riscv用到了bbl，需要修改其添加bootloader的方式
```
$(KERNEL_IMG): $(KERNEL_ELF)
	cd $(TOPDIR)/../riscv-pk && rm -rf build && mkdir build && cd build && ../configure --prefix=$(RISCV) --host=riscv32-unknown-elf --with-payload=$(KERNEL_ELF) --disable-fp-emulation --enable-logo && make && cp bbl $(KERNEL_IMG)
```
同时，为了在ramdisk.c中能正确导入sfsimg和swapimg，需要link binary blob，[参考资料](https://balau82.wordpress.com/2012/02/19/linking-a-binary-blob-with-gcc)，也需要修改makefile的过程，否则会把整个文件路径导入进来，这里稍微有点暴力，有待优化

```
$(KERNEL_ELF): $(LINK_FILE) $(KERNEL_BUILTIN) $(RAMDISK_OBJ) $(SWAPFS_FILE) $(SFSIMG_FILE)
	@echo Linking uCore
	mv $(SWAPFS_FILE) .
	mv $(SFSIMG_FILE) ./sfs.img
	$(Q)$(TARGET_LD) $(TARGET_LDFLAGS) -T $(LINK_FILE) $(KERNEL_BUILTIN) $(RAMDISK_OBJ) -o $@ --format=binary swap.img sfs.img --format=default
	mv swap.img $(SWAPFS_FILE)
	mv sfs.img $(SFSIMG_FILE)
```

# riscv32与riscv64的合并

这部分主要遇到两个难点：一是riscv32和riscv64原先都是在“老”的ucore+上实现的，而现在要整合到“新”的ucore+上，出入还是有一些的；二是riscv64实现了smp，自身对ucore+的框架就有较大的改动

## 主要改动

某些需要兼容的地方修改变量的属性，如从`bool`到`int`,`uint32_t`到`uintptr_t`	

鉴于riscv32和riscv64有许多通用部分，以前riscv32在硬件无关地方所做的修改，面对riscv64只要添加上相应的宏定义即可

添加kmod和sfatfs相关的内容（和g08组实现的内容相关）

### makefile
添加sfsimg2相关内容

针对riscv64，减去numa模块，添加到smp模块（宏定义）

### smp.h
仿照numa/mp.h，根据riscv中的smp修改了`struct cpu`，添加`smp_init`

### sched.c
由于实现了load_balance，以及重定义了cpu，修改了获取cpu的方式

### dev_disk.c
不同于原先的dev_disk0.c和div_disk1.c两个文件，现在完全整合到了一起
```
void dev_init_disk(void)
{
  const int MAX_DISK_SCAN = 10;
  for(int i = 0; i < MAX_DISK_SCAN; i++) {
    if(!ide_device_valid(i)) continue;
    struct inode *node = dev_create_inode();
    if (node == NULL) {
      panic("disk%d: dev_create_node.\n", i);
    }
    disk_device_init(vop_info(node, device), i);
    char* device_name = kmalloc(16);
    //TODO: seems no sprintf is available for kernel?
    strcpy(device_name, "disk0");
    device_name[4] = '0' + i;
    int ret = vfs_add_dev(device_name, node, 1);
  	if (ret != 0) {
  		panic("disk0: vfs_add_dev: %e.\n", ret);
  	}
  }
}
```

### cachet.h
新ucore+增加的模块

## 未来的工作

如今riscv64+smp中有许多地方做得不够优雅，有许多的宏定义来绕开一些兼容问题（尤其是mycpu()的重定义，可以考虑和numa中的mp.h融合到一起），今后可考虑优化

## 实验结果

由于arm的运行需要arm-eabi-gcc，mips的运行需要mips-sde-elf-gcc，基于配置环境繁琐的原因这里未给出真实环境下的实验结果（实际上，有了后面的CI，都可以解决了o((⊙﹏⊙))o）

### i386

<center>
![i386](https://github.com/cxjyxxme/ucore_plus/raw/master/final/i386.png)
i386

![i386test](https://github.com/cxjyxxme/ucore_plus/raw/master/final/i386test.png)
i386test
</center>

### amd64

<center>
![amd64](https://github.com/cxjyxxme/ucore_plus/raw/master/final/amd64.png)
amd64

![amd64test](https://github.com/cxjyxxme/ucore_plus/raw/master/final/amd64test.png)
amd64test
</center>

### riscv32

<center>
![riscv32](https://github.com/cxjyxxme/ucore_plus/raw/master/final/riscv32.png)
riscv32

![riscv32test](https://github.com/cxjyxxme/ucore_plus/raw/master/final/riscv32test.png)
riscv32test
</center>

### riscv64

<center>
![riscv64](https://github.com/cxjyxxme/ucore_plus/raw/master/final/riscv64.png)
riscv64

![riscv64test](https://github.com/cxjyxxme/ucore_plus/raw/master/final/riscv64test.png)
riscv64test
</center>

#ucore+的autotest

##介绍
在完成编译后在ucore目录下执行

    ./uCore_test -d obj

即可，这个脚本会运行ucore/src/user-ucore/tests/中的代码，并且对其输出进行分析，判断是否运行成功。例如：

```
    #include <stdio.h>
    #include <ulib.h>
    
    int main(void)
    {
        cprintf("Hello world!!.\n");
    	cprintf("I am process %d.\n", getpid());
    	cprintf("hello pass.\n");
    	return 0;
    }
```
分析输出正确性的文件位于ucore/src/user-ucore/testspecs/中。例如：
```
    @program    /testbin/hello
    @arch		i386
    
      - 'kernel_execve: pid = [0-9]{1,2}, name = "/testbin/hello".'
        'Hello world!!.'
      - 'I am process [0-9]{1,2}.'
        'hello pass.'
        'all user-mode processes have quit.'
    'init check memory pass.'
```
命令的规则参见：ucore/doc/autotest.rst

在调用uCore_test的过程中会调用到uCore_run执行代码，所以uCore_run中需要对对应的arch编写对应的调用qemu的代码。

##遇到的问题及解决

- lockfile command not found
- 解决：安装procmail包，选择no-configure安装
- 调用了不存在的yaffs硬盘镜像
- 解决：删除uCore_ru中那一行
- 新版ucore+测例无法通过，而老版可以，原因有以下几点：
    - 因为引入了网络模块，后台会跑一个守护进程，test会判断为时无法结束
    - 大部分没通过的测例现在出错是因为页个数check不对，因为vfs文件夹中部分代码使用kmalloc没有释放造成泄漏
    - 因为加入了网络模块，所以对并行测试的支持会有问题，所以改为单线程测试

##目前的进度

这部分的调试主要在i386上进行，进度如下：

![dsd](https://raw.githubusercontent.com/cxjyxxme/ucore_plus/master/final/i386test.png)
![dsd](https://raw.githubusercontent.com/cxjyxxme/ucore_plus/master/final/amd64test.png)

##未来的工作

之前的ucore+的自动测试功能被搁置了，这部分工作的主要目的是重启自动测试功能，
在重启之后可以通过测例来对各个ARCH进行debug。

- 使用自动测试功能调通各个ARCH的测例
- 在用网络模块的基础上重新开启多线程测试

#travis-ci

##介绍

travis-ci是目前新兴的开源持续集成构建项目。它可以在你每次push之后对你的代码进行基于不同环境参数的编译和运行，返回给你结果。
这样就可以很方便地知道是哪次push之后导致了bug的出现。
![](https://raw.githubusercontent.com/cxjyxxme/ucore_plus/master/final/travis-ci%20test.png)
![](https://raw.githubusercontent.com/cxjyxxme/ucore_plus/master/final/travis-ci%20arch.png)

结合之前的自动测试功能，我们实现了一个每次push都会进行编译测试和测例测试并输出测例测试结果的功能。

##遇到的问题及解决
- 由于gdb target remote导致的执行代码卡死
- 解决：原因是travis-CI上环境没安装gdb。uCore_test和uCore_run和misc/evaluate_build.py中又多层隐藏了错误输出，导致定位bug定位了非常久。

##配置riscv的ci遇到的问题及解决
- riscv的工具链要怎么传上去
- 解决：把工具链打包后上传到清华网盘，生成固定直接下载链接，在ci上通过wget下载工具链。
- export PATH无效
- 解决：因为对docker不熟悉，其实docker exec每句话直接的环境变量都是会重新刷新的（类似ubuntu terminal重启），故只能使用 export xxx && xxx的方式实现功能
- 之前用的docker环境是ubuntu17.10，我们用的riscv环境都是16.04的，所以很多动态链接库都没有
- 解决：目前暂时的做法是把我电脑上的so文件都copy到docker里，居然可以work

##未来的工作
- 把docker替换为16.04
- 把工具链上传到docker cloud

#ucore+ SMP的硬件无关部分
##介绍
我调研了xv6的各部分对于多核的处理方式，并且对ucore+进行比较，得出改变方案。
###文件系统
调研了一下文件系统，在ucore+中一个file是可以被多个process同时打开的，打开文件表在每个process中分别维护，打开文件表中每一项有一个struct，
其中包含了这次读写操作对应信息（如文件信息、目前读写的位置等等），ucore+的做法是一个文件可以被同时读写，读写操作相当于直接应用到硬盘，
即把冲突控制交给用户。并且在最底层的文件读写代码中可以发现每次对某个disk的一次读写操作都是带锁的。综上，我觉得SMP不需要对fs做特殊的支持。
###内存管理
mm方面因为页表独立，感觉就是要在申请物理页的时候加个锁(ucore+已经有了)
###调度
调度部分xv6的做法是全局一个runqueue，而ucore+的做法是每个cpu一个runqueue，由某个process fork出来的进程会继续在父进程的cpu的runqueue中，
也就是说如果不进行均衡，所有的进程都会在开始做init的那个cpu执行，所以需要加入balance，平衡runqueue之间的进程。具体做法参考了：https://blog.csdn.net/u010937616/article/details/47396619

##遇到的问题及解决
- ucore+的timer_list是共享的，在跑run_timer_list时的那个cpu会把别的cpu睡觉的进程往自己这里唤醒，导致cpu迷之转移，导致错误
- 解决：更改为每个cpu一个timer_list

##目前的进度
在与路橙组的合作下，rv64在单核通过39/39，开启SMP的情况下测例通过：36/39

##未来的工作
- MLFQ目前是伪MLFQ
- 目前balance部分的get_load没有考虑rq的时间跳跃性
- 测例还没有全部通过，可能还有一些同步互斥问题有待解决

<center>
![riscv64test](https://github.com/cxjyxxme/ucore_plus/raw/master/final/riscv64test.png)
riscv64test
</center>